# <center>安全代理协议设计与实现实验报告</center>

小组成员：陈熠豪2017011 章志宇2017011424

## 一、实验目的

每组设计并实现⼀个⽀持认证、加密的安全代理协议。该协议需要防范攻击者的流量分析。 

1. 浏览器可以通过配置通过设计的安全协议访问HTTP Web⽹站；
2. 协议需要实现加密功能；
3. 浏览器配置代理通信时，需要实现认证登陆功能；
4. 协议需要考虑中间⼈窃听、阻断、 DoS等攻击⻛险，保证协议不会受此类攻击的影响； 

## 二、实验原理

### 2.1加解密算法RSA

RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，在公开密钥密码体制中，加密密钥（即公开密钥）$K_p$是公开信息，而解密密钥（即秘密密钥）$K_S$是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥$K_P$决定的，但却不能根据$K_P$计算出$K_S$

RSA算法的具体描述如下：

（1）任意选取两个不同的大素数p和q计算乘积

 ![img](https://bkimg.cdn.bcebos.com/formula/f0dac18152076624d87832b62709895c.svg) 

（2）任意选取一个大整数e，满足

 ![img](https://bkimg.cdn.bcebos.com/formula/c33d8c66364a636b051d82f0ee202a36.svg)  ，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用）

（3）确定的解密钥d，满足 ![img](https://bkimg.cdn.bcebos.com/formula/da8649c0078a0a842779394d64011776.svg)  ，即 ![img](https://bkimg.cdn.bcebos.com/formula/4dee3f4df52a81983db0e3c619f96058.svg)  是一个任意的整数；所以，若知道e和 ![img](https://bkimg.cdn.bcebos.com/formula/679e809a0d964785d0aa4cfcb4218742.svg) ，则很容易计算出d

（4）公开整数n和e，秘密保存d

（5）将明文m（m<n是一个整数）加密成密文c，加密算法为 ![img](https://bkimg.cdn.bcebos.com/formula/5947116555169dc6fe9e3f5cdf347706.svg) 

（6）将密文c解密为明文m，解密算法为 ![img](https://bkimg.cdn.bcebos.com/formula/1a8b337167e4d4b2c23855d88ec4c67f.svg) 

然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密

### 2.2代理服务协议

Web 代理是一种存在于网络中间的实体，提供各式各样的功能。我们的代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。

![img](https://img-blog.csdnimg.cn/2019042511255890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lldHVnZW5n,size_16,color_FFFFFF,t_70)

我们在代理和客户端的传输中进行了加密和认证。

“只要我们把代理服务器部署在海外，它就是一个合格的VPN”豪哥如是说

## 三、具体实现

### 3.1密钥生成

密钥生成涉及算法如下

#### 3.1.1快速幂

$$a^b\equiv\ ?\ (mod\ p)$$，对a,b,p没有特殊要求的快速做法，对于小整数p时间复杂度O(logb)

#### 3.1.2 拓展欧几里得

$$ax+by=(a,b)​$$已知a,b，求x,y，时间复杂度O(logmax(a,b))

#### 3.1.3 Miller_Rabin判素数

对p，令$$2^q*m= p - 1$$，若p是质数，则对任意a有$$a^{2^q*m}\equiv1(mod\ p)$$且（$$a^m\equiv1(mod\ p)$$或者$$a^{2^1*m}\equiv -1(mod\ p),a^{2^2*m}\equiv -1 (mod\ p),...,a^{2^q*m}\equiv -1 (mod\ p),$$中至少一个成立

该方法对一个特定的a，若后者成立，p有75%是质数，所以，只需要取若干个随机的a都满足条件就可以比较确定p是质数

全部用函数实现在functions.py中

### 3.2加解密算法

对于密钥[d, n]，分组长度为k1=log2(n)下取整，需要把输入字符串转成字节比特流，由于1个字节8比特，但分组长度不一定是8的倍数，所以非常不规整，实现起来很有挑战性，要考虑很多边界条件，我们其实也只是试了有限的数据，确保没有问题，但并不保证完全没有问题，解密和加密类似，区别体现在分组长度为k2=log2(n)+1下取整。因为RSA算法需要满足每个分组的最大值都不能比钥匙中的n更大，加密之后可以保证k2的长度的数都满足，但加密前是无法保证的。简而言之就是加密时把k1个bit转换成了k2个bit，解密时把k2个bit转换成了k1个bit，其中k2=k1+1

其中还涉及了很多字符串和字节流的转换，latin1的方式才能够编码0~255，默认是0~127

这一部分在encrypt.py中用函数做了实现，由于时间紧迫，没有太注意工程规范。

### 3.3加解密流程

为了方便解释，这里只讲从Client（Alice）到Server（Bob）的通信（从Server到Client是完全一样的）：首先Alice用自己的私钥加密，相当于盖了一个章，表示这是Alice发出去的消息，然后为了方便判断消息是完整的，在最后添加了特定的字符串"hello bro!"，然后再用Bob的公钥加密，这就全部是密文，而且除了Bob之外的任何人都只能看到密文。消息传递到Bob手中后，Bob用自己的私钥解密，然后看到消息末尾是"hello bro!"说明消息完整，最后再用Alice的公钥把"hello bro!"前面的密文解密，得到真正的明文，确认是Alice发出的。

这一部分也是在encrypt.py中实现的

## 四、成果展示

## 五、思考与反省

在实现加解密算法的过程中，小组成员充分复习了初等数论和加解密技术，对RSA算法更加熟悉了。当然，严格讲我们完成的也不是特别完美的RSA，因为运行时间有限，密钥也没有设的很大。字节流处理起来真的很费劲，主要是不以字节为单位，而是连着取若干bit形成一组一组，位运算算的脑仁疼，而且加密或解密后还得拼起来，数、字符串、字节流转换的非常频繁，中间还出现了一些编码错误和未知的截断错误。我们在nodejs向python传数据的时候莫名发生了字符串被截断的问题，后来采用先写进文件中再输入到python程序的方法才得以解决。

临近期末，本次实验完成得非常紧张，几乎可以说是蹭着ddl走钢丝。

## 六、小组分工

本次实验由陈熠豪同学完成代理服务的设计和编写，由章志宇同学完成密钥生成和加解密算法的实现